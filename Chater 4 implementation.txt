CHAPTER IV IMPLEMENTATION

4.1 Implementation of CRUD Data Collection of Fiber Optics Topology and Inventory Information

The implementation of the Fiber Optics Topology and Inventory Information system was developed using a modern web application architecture with Laravel PHP framework for the backend API and React TypeScript for the frontend client application. This system provides comprehensive CRUD (Create, Read, Update, Delete) operations for managing fiber optic infrastructure components including locations, ODCs (Optical Distribution Cabinets), cables, tubes, cores, ODPs (Optical Distribution Points), and FTTH clients.

4.1.1 Fiber Optics Backend Implementation

The backend implementation was built using Laravel 10 framework with a RESTful API architecture. The system consists of seven main entities that form a hierarchical structure representing the fiber optic network topology.

4.1.1.1 Database Schema Design

The database schema was designed with proper relationships and constraints to maintain data integrity. Each table implements soft deletes for data preservation and includes status management for active/archived states.

**FoLokasi (Locations) Table:**
```php
Schema::create('fo_lokasis', function (Blueprint $table) {
    $table->id();
    $table->string('nama_lokasi');
    $table->string('deskripsi')->nullable();
    $table->decimal('latitude', 10, 7);
    $table->decimal('longitude', 10, 7);
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
```

**FoOdc (Optical Distribution Cabinets) Table:**
```php
Schema::create('fo_odcs', function (Blueprint $table) {
    $table->id();
    $table->foreignId('lokasi_id')->constrained('fo_lokasis')->cascadeOnDelete()->cascadeOnUpdate();
    $table->string('nama_odc');
    $table->enum('tipe_splitter', ['1:2', '1:4', '1:8', '1:16', '1:32', '1:64', '1:128']);
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
```

**FoKabelOdc (ODC Cables) Table with Automatic Core Calculation:**
```php
Schema::create('fo_kabel_odcs', function (Blueprint $table) {
    $table->id();
    $table->foreignId('odc_id')->constrained('fo_odcs')->cascadeOnDelete()->cascadeOnUpdate();
    $table->string('nama_kabel');
    $table->enum('tipe_kabel', ['singlecore', 'multicore']);
    $table->decimal('panjang_kabel', 8, 2);
    $table->integer('jumlah_tube');
    $table->integer('jumlah_core_in_tube');
    $table->integer('jumlah_total_core'); // Auto-calculated
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
```

The automatic calculation of total cores is implemented in the model using Laravel's model events:
```php
protected static function boot()
{
    parent::boot();

    // Before every save (create or update), recalc jumlah_total_core
    static::saving(function (FoKabelOdc $model) {
        $model->jumlah_total_core = $model->jumlah_tube * $model->jumlah_core_in_tube;
    });
}
```

4.1.1.2 Model Relationships and Eloquent ORM

The Laravel Eloquent models were implemented with proper relationships to maintain data integrity and enable efficient querying:

```php
// app/Models/FoLokasi.php
class FoLokasi extends Model
{
    use SoftDeletes;

    protected $fillable = [
        'nama_lokasi', 'deskripsi', 'latitude', 'longitude', 'status'
    ];

    protected $casts = [
        'latitude' => 'float',
        'longitude' => 'float',
        'status' => 'string',
        'deleted_at' => 'datetime',
    ];

    public function odcs()
    {
        return $this->hasMany(FoOdc::class, 'lokasi_id');
    }

    public function odps()
    {
        return $this->hasMany(FoOdp::class, 'lokasi_id');
    }

    public function clientFtths()
    {
        return $this->hasMany(FoClientFtth::class, 'lokasi_id');
    }
}
```

4.1.1.3 API Controller Implementation

Six RESTful controllers were implemented with comprehensive CRUD operations. Each controller follows Laravel best practices with proper validation, error handling, and response formatting.

**FoLokasiController - Index Method with Advanced Filtering:**
```php
public function index(Request $request)
{
    // Parse status parameter for filtering
    $statusParam = $request->query('status', 'active');
    $requested = collect(explode(',', $statusParam))
        ->map(fn($s) => trim(strtolower($s)))
        ->filter()
        ->unique()
        ->values()
        ->all();

    $validStatuses = ['active', 'archived', 'deleted'];
    $statuses = array_values(array_intersect($requested, $validStatuses));
    if (empty($statuses)) {
        $statuses = ['active'];
    }

    // Base query with trashed support
    $query = FoLokasi::withTrashed();

    // Filter by status with complex logic
    $query->where(function ($q) use ($statuses) {
        if (in_array('deleted', $statuses, true)) {
            $q->orWhereNotNull('deleted_at');
        }

        $nonDeleted = array_values(array_intersect($statuses, ['active', 'archived']));
        if (!empty($nonDeleted)) {
            $q->orWhere(function ($sub) use ($nonDeleted) {
                $sub->whereNull('deleted_at')
                    ->whereIn('status', $nonDeleted);
            });
        }
    });

    // Text filtering
    if ($request->filled('filter')) {
        $term = $request->query('filter');
        $query->where(function ($q) use ($term) {
            $q->where('nama_lokasi', 'LIKE', "%{$term}%")
                ->orWhere('deskripsi', 'LIKE', "%{$term}%");
        });
    }

    // Sorting with validation
    if ($request->filled('sort')) {
        [$column, $dir] = array_pad(explode('|', $request->query('sort')), 2, null);
        $dir = (strtolower($dir) === 'dsc') ? 'desc' : 'asc';

        $allowedSorts = ['id', 'nama_lokasi', 'created_at', 'updated_at', 'status'];
        if (in_array($column, $allowedSorts, true)) {
            $query->orderBy($column, $dir);
        }
    } else {
        $query->orderBy('id', 'desc');
    }

    // Pagination with relationship loading
    $perPage = (int) $request->query('per_page', 15);
    if ($perPage <= 0) $perPage = 15;

    $paginator = $query
        ->with(['odcs', 'odps', 'clientFtths'])
        ->paginate($perPage)
        ->appends($request->only(['filter', 'sort', 'per_page', 'status']));

    // Transform data for consistent response
    $data = array_map(function ($l) {
        return [
            'id' => $l->id,
            'nama_lokasi' => $l->nama_lokasi,
            'deskripsi' => $l->deskripsi,
            'latitude' => $l->latitude,
            'longitude' => $l->longitude,
            'status' => $l->status,
            'odcs' => $l->odcs->map(fn($o) => [
                'id' => $o->id,
                'nama_odc' => $o->nama_odc,
            ])->toArray(),
            'odps' => $l->odps->map(fn($o) => [
                'id' => $o->id,
                'nama_odp' => $o->nama_odp,
            ])->toArray(),
            'clients' => $l->clientFtths->map(fn($c) => [
                'id' => $c->id,
                'nama_client' => $c->nama_client,
            ])->toArray(),
            'created_at' => $l->created_at->toDateTimeString(),
            'updated_at' => $l->updated_at->toDateTimeString(),
            'deleted_at' => $l->deleted_at?->toDateTimeString(),
        ];
    }, $paginator->items());

    return response()->json([
        'status' => 'success',
        'data' => $data,
        'meta' => [
            'current_page' => $paginator->currentPage(),
            'per_page' => $paginator->perPage(),
            'total' => $paginator->total(),
            'last_page' => $paginator->lastPage(),
            'from' => $paginator->firstItem(),
            'to' => $paginator->lastItem(),
        ],
    ], 200);
}
```

**Store Method with Validation:**
```php
public function store(Request $request)
{
    $data = $request->validate([
        'nama_lokasi' => 'required|string|max:255',
        'deskripsi' => 'nullable|string|max:255',
        'latitude' => 'required|numeric',
        'longitude' => 'required|numeric',
        'status' => 'sometimes|in:active,archived',
    ]);

    // Default to active if not provided
    if (!isset($data['status'])) {
        $data['status'] = 'active';
    }

    $lokasi = FoLokasi::create($data);

    return response()->json([
        'status' => 'success',
        'data' => [
            'id' => $lokasi->id,
            'nama_lokasi' => $lokasi->nama_lokasi,
            'deskripsi' => $lokasi->deskripsi,
            'latitude' => $lokasi->latitude,
            'longitude' => $lokasi->longitude,
            'status' => $lokasi->status,
            'created_at' => $lokasi->created_at->toDateTimeString(),
            'updated_at' => $lokasi->updated_at->toDateTimeString(),
        ],
        'message' => 'Lokasi created.',
    ], 201);
}
```

**Bulk Operations Implementation:**
```php
public function bulk(Request $request)
{
    $data = $request->validate([
        'action' => 'required|in:archive,delete,restore',
        'ids' => 'required|array|min:1',
        'ids.*' => 'integer|distinct',
    ]);

    $ids = $data['ids'];
    $action = $data['action'];

    switch ($action) {
        case 'archive':
            $this->model::withTrashed()
                ->whereIn('id', $ids)
                ->update(['status' => 'archived']);
            $message = 'Items archived.';
            break;

        case 'delete':
            $this->model::whereIn('id', $ids)->delete();
            $message = 'Items soft‐deleted.';
            break;

        case 'restore':
            $this->model::onlyTrashed()
                ->whereIn('id', $ids)
                ->restore();
            $this->model::whereIn('id', $ids)
                ->update(['status' => 'active']);
            $message = 'Items restored to active.';
            break;

        default:
            return response()->json([
                'status' => 'error',
                'message' => 'Invalid action.',
            ], 422);
    }

    return response()->json([
        'status' => 'success',
        'message' => $message,
    ], 200);
}
```

4.1.1.4 API Route Configuration

The API routes were configured with proper middleware and RESTful patterns:

```php
Route::group(['middleware' => ['throttle:api', 'api_db', 'token_auth', 'locale'], 'prefix' => 'api/v1', 'as' => 'api.'], function () {

    // FoLokasi Routes
    Route::get('/fo-lokasis', [FoLokasiController::class, 'index']);
    Route::post('/fo-lokasis', [FoLokasiController::class, 'store']);
    Route::get('/fo-lokasis/{id}', [FoLokasiController::class, 'show']);
    Route::put('/fo-lokasis/{id}', [FoLokasiController::class, 'update']);
    Route::patch('/fo-lokasis/{id}', [FoLokasiController::class, 'update']);
    Route::delete('/fo-lokasis/{id}', [FoLokasiController::class, 'destroy']);
    Route::patch('/fo-lokasis/{id}/archive', [FoLokasiController::class, 'archive']);
    Route::patch('/fo-lokasis/{id}/unarchive', [FoLokasiController::class, 'unarchive']);
    Route::patch('/fo-lokasis/{id}/restore', [FoLokasiController::class, 'restore']);
    Route::post('/fo-lokasis/bulk', [FoLokasiController::class, 'bulk']);

    // Similar patterns for all other entities...
    Route::get('/fo-odcs', [FoOdcController::class, 'index']);
    Route::post('/fo-odcs', [FoOdcController::class, 'store']);
    // ... additional routes for each entity
});
```

4.1.1.5 Advanced Validation and Business Logic

Complex validation rules were implemented for maintaining data integrity:

```php
// FoOdpController - Complex validation for unique core assignment
public function store(Request $request)
{
    $data = $request->validate([
        'lokasi_id' => 'required|exists:fo_lokasis,id',
        'kabel_core_odc_id' => [
            'required',
            'exists:fo_kabel_core_odcs,id',
            Rule::unique('fo_odps')->where(function ($query) {
                return $query->whereNull('deleted_at');
            })
        ],
        'nama_odp' => 'required|string|max:255',
        'status' => 'sometimes|in:active,archived',
    ]);

    // Check if core is already assigned to another ODP
    $existingOdp = FoOdp::where('kabel_core_odc_id', $data['kabel_core_odc_id'])
        ->whereNull('deleted_at')
        ->first();

    if ($existingOdp) {
        return response()->json([
            'status' => 'error',
            'message' => 'This core is already assigned to ODP: ' . $existingOdp->nama_odp,
        ], 422);
    }

    if (!isset($data['status'])) {
        $data['status'] = 'active';
    }

    $odp = FoOdp::create($data);
    $odp->load(['lokasi', 'kabelCoreOdc.kabelTubeOdc.kabelOdc.odc.lokasi']);

    return response()->json([
        'status' => 'success',
        'data' => $this->transformOdpData($odp),
        'message' => 'ODP created successfully.',
    ], 201);
}
```

4.1.2 Fiber Optics Frontend Implementation

The frontend implementation was developed using React 18 with TypeScript, providing a modern, responsive user interface for managing the fiber optics infrastructure.

4.1.2.1 Application Architecture and Route Configuration

The frontend follows a modular architecture with comprehensive routing:

```typescript
// client/src/common/routes.tsx
import { foLokasiRoutes } from '$app/pages/fo-lokasis/routes';
import { foOdcRoutes } from '$app/pages/fo-odcs/routes';
import { foKabelOdcRoutes } from '$app/pages/fo-kabel-odcs/routes';
import { foKabelTubeOdcRoutes } from '$app/pages/fo-kabel-tube-odcs/routes';
import { foKabelCoreOdcRoutes } from '$app/pages/fo-kabel-core-odcs/routes';
import { foOdpRoutes } from '$app/pages/fo-odps/routes';
import { foClientFtthRoutes } from '$app/pages/fo-client-ftths/routes';

export const routes = (
    <Routes>
        <Route path="/" element={<Index />} />
        {authenticationRoutes}
        <Route element={<PrivateRoute />}>
            <Route path="/dashboard" element={<Dashboard />} />
            {foLokasiRoutes}
            {foOdcRoutes}
            {foKabelOdcRoutes}
            {foKabelTubeOdcRoutes}
            {foKabelCoreOdcRoutes}
            {foOdpRoutes}
            {foClientFtthRoutes}
        </Route>
    </Routes>
);
```

4.1.2.2 Data Management with React Query

Custom hooks were implemented for each entity using React Query for efficient server state management:

```typescript
// client/src/common/queries/foLokasi.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { request } from '$app/common/helpers/request';
import { toast } from '$app/common/helpers/toast/toast';

export function useFoLokasiQuery(params?: {
    page?: number;
    per_page?: number;
    filter?: string;
    sort?: string;
    status?: string;
}) {
    return useQuery({
        queryKey: ['fo-lokasis', params],
        queryFn: () => request('GET', '/api/v1/fo-lokasis', { params }),
        staleTime: 5 * 60 * 1000, // 5 minutes
    });
}

export function useCreateFoLokasiMutation() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: (data: any) => request('POST', '/api/v1/fo-lokasis', data),
        onSuccess: () => {
            queryClient.invalidateQueries({ queryKey: ['fo-lokasis'] });
            toast.success('Lokasi created successfully');
        },
        onError: (error: any) => {
            toast.error(error?.data?.message || 'Failed to create lokasi');
        },
    });
}

export function useFoLokasiBulkAction() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: ({ action, ids }: { action: string; ids: string[] }) =>
            request('POST', '/api/v1/fo-lokasis/bulk', { action, ids }),
        onSuccess: (_, { action }) => {
            queryClient.invalidateQueries({ queryKey: ['fo-lokasis'] });
            toast.success(`Items ${action}d successfully`);
        },
        onError: (error: any) => {
            toast.error(error?.data?.message || 'Bulk operation failed');
        },
    });
}
```

4.1.2.3 Component Implementation with TypeScript

Comprehensive TypeScript interfaces and components were developed:

```typescript
// client/src/pages/fo-lokasis/common/hooks2.tsx
export interface FoLokasi {
    id: string;
    nama_lokasi: string;
    deskripsi?: string;
    latitude: number;
    longitude: number;
    status: 'active' | 'archived' | string;
    odcs: Array<{ id: string; nama_odc: string }>;
    odps: Array<{ id: string; nama_odp: string }>;
    clients: Array<{ id: string; nama_client: string }>;
    created_at: string;
    updated_at: string;
    deleted_at?: string | null;
}

export function useFoLokasiColumns() {
    const { t } = useTranslation();

    return useMemo(
        () => [
            {
                column: 'nama_lokasi',
                id: 'nama_lokasi',
                label: t('nama_lokasi'),
                format: (value: string) => value,
            },
            {
                column: 'deskripsi',
                id: 'deskripsi',
                label: t('deskripsi'),
                format: (value: string) => value || '-',
            },
            {
                column: 'latitude',
                id: 'latitude',
                label: t('latitude'),
                format: (value: number) => value.toFixed(6),
            },
            {
                column: 'longitude',
                id: 'longitude',
                label: t('longitude'),
                format: (value: number) => value.toFixed(6),
            },
            {
                column: 'status',
                id: 'status',
                label: t('status'),
                format: (value: string) => (
                    <Badge variant={value === 'active' ? 'success' : 'secondary'}>
                        {t(value)}
                    </Badge>
                ),
            },
            {
                column: 'created_at',
                id: 'created_at',
                label: t('created_at'),
                format: (value: string) => formatDate(value),
            },
        ],
        [t]
    );
}
```

4.1.2.4 Form Implementation with Validation

Advanced form components with real-time validation:

```typescript
// client/src/pages/fo-lokasis/common/components/CreateFoLokasi.tsx
interface FoLokasi {
    nama_lokasi: string;
    deskripsi?: string;
    latitude: number;
    longitude: number;
}

interface Props {
    foLokasi: FoLokasi;
    errors?: ValidationBag;
    setFoLokasi: Dispatch<SetStateAction<FoLokasi>>;
    setErrors: Dispatch<SetStateAction<ValidationBag | undefined>>;
}

export function CreateFoLokasi(props: Props) {
    const { foLokasi, errors, setFoLokasi, setErrors } = props;

    const handleChange = <K extends keyof FoLokasi>(
        field: K,
        value: FoLokasi[K]
    ) => {
        setFoLokasi((prev) => ({ ...prev, [field]: value }));
        setErrors(undefined);
    };

    return (
        <div className="grid grid-cols-12 gap-4">
            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('nama_lokasi')}
                    value={foLokasi.nama_lokasi}
                    onValueChange={(value) => handleChange('nama_lokasi', value)}
                    errorMessage={errors?.errors.nama_lokasi}
                    required
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('deskripsi')}
                    value={foLokasi.deskripsi || ''}
                    onValueChange={(value) => handleChange('deskripsi', value)}
                    errorMessage={errors?.errors.deskripsi}
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('latitude')}
                    type="number"
                    step="any"
                    value={foLokasi.latitude.toString()}
                    onValueChange={(value) => handleChange('latitude', parseFloat(value) || 0)}
                    errorMessage={errors?.errors.latitude}
                    required
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('longitude')}
                    type="number"
                    step="any"
                    value={foLokasi.longitude.toString()}
                    onValueChange={(value) => handleChange('longitude', parseFloat(value) || 0)}
                    errorMessage={errors?.errors.longitude}
                    required
                />
            </div>
        </div>
    );
}
```

4.1.2.5 Index Component with Advanced Features

Data grid implementation with filtering, sorting, and bulk operations:

```typescript
// client/src/pages/fo-lokasis/index/FoLokasis.tsx
export default function FoLokasis() {
    const { t } = useTranslation();
    const [currentPage, setCurrentPage] = useState(1);
    const [perPage, setPerPage] = useState(15);
    const [filter, setFilter] = useState('');
    const [sort, setSort] = useState('');
    const [status, setStatus] = useState('active');
    const [selectedIds, setSelectedIds] = useState<string[]>([]);

    const { data, isLoading } = useFoLokasiQuery({
        page: currentPage,
        per_page: perPage,
        filter,
        sort,
        status,
    });

    const bulkAction = useFoLokasiBulkAction();

    const handleBulkAction = (action: 'archive' | 'delete' | 'restore') => {
        if (selectedIds.length === 0) {
            toast.error('Please select items to perform bulk action');
            return;
        }

        bulkAction.mutate({ action, ids: selectedIds });
        setSelectedIds([]);
    };

    const columns = useFoLokasiColumns();
    const actions = useFoLokasiActions();

    return (
        <Default
            title={t('fo_lokasis')}
            breadcrumbs={[
                { name: t('fo_lokasis'), href: '/fo-lokasis' },
            ]}
            topRight={
                <Link to="/fo-lokasis/create">
                    <Button>{t('new_fo_lokasi')}</Button>
                </Link>
            }
        >
            <DataTable
                resource="fo_lokasis"
                columns={columns}
                data={data?.data || []}
                isLoading={isLoading}
                pagination={{
                    currentPage,
                    setCurrentPage,
                    perPage,
                    setPerPage,
                    total: data?.meta?.total || 0,
                }}
                filters={{
                    filter,
                    setFilter,
                    status,
                    setStatus,
                }}
                sorting={{
                    sort,
                    setSort,
                }}
                bulkActions={{
                    selectedIds,
                    setSelectedIds,
                    actions: [
                        {
                            label: t('archive'),
                            onClick: () => handleBulkAction('archive'),
                        },
                        {
                            label: t('delete'),
                            onClick: () => handleBulkAction('delete'),
                        },
                        {
                            label: t('restore'),
                            onClick: () => handleBulkAction('restore'),
                        },
                    ],
                }}
                actions={actions}
            />
        </Default>
    );
}
```

4.1.2.6 Complex Form with Relationship Management

Advanced form implementation for entities with complex relationships:

```typescript
// client/src/pages/fo-odcs/common/components/CreateFoOdc.tsx
export interface FoOdcFormValues {
    create_new_lokasi: boolean;
    lokasi_id: string;
    lokasi_name: string;
    lokasi_deskripsi: string;
    lokasi_latitude: string;
    lokasi_longitude: string;
    nama_odc: string;
    tipe_splitter: string;
}

interface Props {
    values: FoOdcFormValues;
    setValues: React.Dispatch<React.SetStateAction<FoOdcFormValues>>;
    lokasis: LokasiOption[];
    errors?: ValidationBag;
}

export function CreateFoOdc({ values, setValues, lokasis, errors }: Props) {
    const { t } = useTranslation();

    const onChange = <K extends keyof FoOdcFormValues>(
        field: K,
        value: FoOdcFormValues[K]
    ) => setValues((v) => ({ ...v, [field]: value }));

    return (
        <div className="grid grid-cols-12 gap-4">
            <div className="col-span-12">
                <Checkbox
                    label={t('create_new_lokasi')}
                    checked={values.create_new_lokasi}
                    onValueChange={(value) => onChange('create_new_lokasi', value)}
                />
            </div>

            {values.create_new_lokasi ? (
                // New location form fields
                <>
                    <div className="col-span-12 lg:col-span-6">
                        <InputField
                            label={t('lokasi_name')}
                            value={values.lokasi_name}
                            onValueChange={(value) => onChange('lokasi_name', value)}
                            errorMessage={errors?.errors['lokasi.name']}
                            required
                        />
                    </div>
                    {/* Additional location fields */}
                </>
            ) : (
                // Existing location selection
                <div className="col-span-12 lg:col-span-6">
                    <SelectField
                        label={t('lokasi')}
                        value={values.lokasi_id}
                        onValueChange={(value) => onChange('lokasi_id', value)}
                        errorMessage={errors?.errors.lokasi_id}
                        required
                    >
                        <option value="">{t('select_lokasi')}</option>
                        {lokasis.map((lokasi) => (
                            <option key={lokasi.id} value={lokasi.id}>
                                {lokasi.nama_lokasi}
                            </option>
                        ))}
                    </SelectField>
                </div>
            )}

            <div className="col-span-12 lg:col-span-6">
                <InputField
                    label={t('nama_odc')}
                    value={values.nama_odc}
                    onValueChange={(value) => onChange('nama_odc', value)}
                    errorMessage={errors?.errors.nama_odc}
                    required
                />
            </div>

            <div className="col-span-12 lg:col-span-6">
                <SelectField
                    label={t('tipe_splitter')}
                    value={values.tipe_splitter}
                    onValueChange={(value) => onChange('tipe_splitter', value)}
                    errorMessage={errors?.errors.tipe_splitter}
                    required
                >
                    <option value="">{t('select_splitter')}</option>
                    <option value="1:2">1:2</option>
                    <option value="1:4">1:4</option>
                    <option value="1:8">1:8</option>
                    <option value="1:16">1:16</option>
                    <option value="1:32">1:32</option>
                    <option value="1:64">1:64</option>
                    <option value="1:128">1:128</option>
                </SelectField>
            </div>
        </div>
    );
}
```

4.1.2.7 Error Handling and User Feedback

Comprehensive error handling and user feedback mechanisms:

```typescript
// client/src/pages/fo-lokasis/create/Create.tsx
export default function Create() {
    const { t } = useTranslation();
    const navigate = useNavigate();

    const [foLokasi, setFoLokasi] = useState<FoLokasi>({
        nama_lokasi: '',
        deskripsi: '',
        latitude: 0,
        longitude: 0,
    });

    const [errors, setErrors] = useState<ValidationBag>();

    const createMutation = useCreateFoLokasiMutation();

    const handleSave = (event: FormEvent) => {
        event.preventDefault();

        if (!foLokasi.nama_lokasi.trim()) {
            setErrors({ errors: { nama_lokasi: [t('nama_lokasi_required')] } });
            return;
        }

        createMutation.mutate(foLokasi, {
            onSuccess: () => {
                navigate('/fo-lokasis');
            },
            onError: (error: any) => {
                if (error?.data?.errors) {
                    setErrors(error.data);
                }
            },
        });
    };

    return (
        <Default
            title={t('new_fo_lokasi')}
            breadcrumbs={[
                { name: t('fo_lokasis'), href: '/fo-lokasis' },
                { name: t('new_fo_lokasi'), href: '/fo-lokasis/create' },
            ]}
            onSaveClick={handleSave}
            disableSaveButton={createMutation.isPending}
        >
            <form onSubmit={handleSave}>
                <CreateFoLokasi
                    foLokasi={foLokasi}
                    errors={errors}
                    setFoLokasi={setFoLokasi}
                    setErrors={setErrors}
                />
            </form>
        </Default>
    );
}
```

4.1.2.8 Performance Optimization and Caching

The frontend implements several performance optimizations:

```typescript
// React Query configuration for optimal caching
const queryClient = new QueryClient({
    defaultOptions: {
        queries: {
            staleTime: 5 * 60 * 1000, // 5 minutes
            cacheTime: 10 * 60 * 1000, // 10 minutes
            retry: 3,
            retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
        },
        mutations: {
            retry: 1,
        },
    },
});

// Optimistic updates for better UX
export function useUpdateFoLokasiMutation() {
    const queryClient = useQueryClient();

    return useMutation({
        mutationFn: ({ id, data }: { id: string; data: any }) =>
            request('PUT', `/api/v1/fo-lokasis/${id}`, data),
        onMutate: async ({ id, data }) => {
            // Cancel outgoing refetches
            await queryClient.cancelQueries({ queryKey: ['fo-lokasis'] });

            // Snapshot previous value
            const previousLokasis = queryClient.getQueryData(['fo-lokasis']);

            // Optimistically update
            queryClient.setQueryData(['fo-lokasis'], (old: any) => ({
                ...old,
                data: old.data.map((lokasi: any) =>
                    lokasi.id === id ? { ...lokasi, ...data } : lokasi
                ),
            }));

            return { previousLokasis };
        },
        onError: (err, variables, context) => {
            // Rollback on error
            if (context?.previousLokasis) {
                queryClient.setQueryData(['fo-lokasis'], context.previousLokasis);
            }
        },
        onSettled: () => {
            // Always refetch after error or success
            queryClient.invalidateQueries({ queryKey: ['fo-lokasis'] });
        },
    });
}
```

The implementation provides a comprehensive, scalable, and user-friendly system for managing fiber optics infrastructure with proper data integrity, performance optimization, and security measures. The modular architecture allows for easy maintenance and future enhancements while providing a robust foundation for fiber optics network management. The combination of Laravel's robust backend capabilities with React's modern frontend features creates a powerful and efficient system for managing complex hierarchical data relationships in fiber optics infrastructure.

4.2 Implementation of FTTH Reports

The FTTH (Fiber to the Home) reporting system provides comprehensive analytics and insights into the fiber optics infrastructure through a dedicated backend API and an advanced frontend dashboard. This section details the implementation of the reporting system, focusing on the backend aggregation, frontend architecture, and the four main report tabs: Overview, Utilization, Status, and Details.

4.2.1 Backend API Implementation

The FTTH reporting system is powered by a centralized API endpoint (`/api/v1/ftth-statistics`) implemented in the `FtthStatisticController`. This endpoint aggregates data from all fiber optics entities and provides statistics, status breakdowns, utilization metrics, and detailed hierarchical data for frontend visualization.

**Example: FTTH Statistics Controller**
```php
// app/Http/Controllers/FtthStatisticController.php
public function index(): JsonResponse
{
    // Aggregate counts and statistics
    $lokasiCount = FoLokasi::count();
    $odcCount = FoOdc::count();
    $odpCount = FoOdp::count();
    $kabelOdcCount = FoKabelOdc::count();
    $kabelCoreOdcCount = FoKabelCoreOdc::count();
    $kabelTubeOdcCount = FoKabelTubeOdc::count();
    $clientFtthCount = FoClientFtth::count();
    $totalKabelLength = FoKabelOdc::sum('panjang_kabel');
    // ... Utilization and status calculations ...
    // ... Chart data preparation ...
    // ... Detailed data for drill-down ...
    return response()->json([
        'data' => [
            'summary' => [...],
            'status' => [...],
            'utilization' => [...],
            'charts' => [...],
            'detailed' => [...],
        ]
    ]);
}
```

The controller also implements helper methods for advanced aggregation, such as `getOdpsPerOdc()`, `getClientsPerOdp()`, and `getDetailedData()`, which traverse relationships and prepare data for frontend charts and tables.

4.2.2 Frontend Dashboard Architecture

The frontend FTTH Reports dashboard is implemented in React (TypeScript) and is organized into four main tabs/pages: **Overview**, **Utilization**, **Status**, and **Details**. Each tab is a separate component that fetches and visualizes data from the centralized API, providing interactive charts, summary cards, and export features.

### 4.2.2.1 Overview Tab

The **Overview** tab provides a high-level summary of the FTTH infrastructure, including total counts and key metrics, as well as bar charts for ODPs per ODC and clients per ODP.

**Key Features:**
- Summary cards for total locations, ODCs, ODPs, cables, tubes, cores, FTTH clients, and utilization rates.
- Bar charts visualizing the distribution of ODPs across ODCs and clients across ODPs.
- Export buttons for CSV and PDF.

**Example: Overview Tab Implementation**
```typescript
// client/src/pages/fo-reports/Overview.tsx
export default function Overview() {
  const [summary, setSummary] = useState({ ... });
  const [odpsPerOdc, setOdpsPerOdc] = useState<any[]>([]);
  const [clientsPerOdp, setClientsPerOdp] = useState<any[]>([]);
  useEffect(() => {
    request('GET', endpoint('/api/v1/ftth-statistics'))
      .then((response) => {
        setSummary(response.data.data.summary);
        setOdpsPerOdc(response.data.data.charts.odpsPerOdc);
        setClientsPerOdp(response.data.data.charts.clientsPerOdp);
      });
  }, []);
  // ... Export handlers ...
  return (
    <div>
      {/* Summary Cards */}
      {/* Bar Charts for ODPs per ODC and Clients per ODP */}
      {/* Export Buttons */}
    </div>
  );
}
```

**Explanation:**
- The tab fetches summary and chart data from the API and displays it using custom `Card` and chart components (`BarChart` from Recharts).
- Export handlers allow users to download the summary as CSV or PDF, using libraries like `jsPDF` and `html2canvas` for PDF rendering.

### 4.2.2.2 Utilization Tab

The **Utilization** tab analyzes resource usage across the FTTH network, focusing on how many cores, tubes, and ODPs are actively used versus available.

**Key Features:**
- Summary cards for total/assigned cores, total/used tubes, total ODPs, and ODPs with clients.
- Pie charts visualizing utilization rates for cores, tubes, and ODPs.
- Export buttons for CSV and PDF.

**Example: Utilization Tab Implementation**
```typescript
// client/src/pages/fo-reports/Utilization.tsx
export default function Utilization() {
  const [summary, setSummary] = useState({ ... });
  const [coreUtil, setCoreUtil] = useState<any[]>([]);
  const [tubeUtil, setTubeUtil] = useState<any[]>([]);
  const [odpUtil, setOdpUtil] = useState<any[]>([]);
  useEffect(() => {
    request('GET', endpoint('/api/v1/ftth-statistics'))
      .then((response) => {
        setSummary(response.data.data.utilization);
        setCoreUtil(response.data.data.charts.coreUtilization);
        setTubeUtil(response.data.data.charts.tubeUtilization);
        setOdpUtil(response.data.data.charts.odpUtilization);
      });
  }, []);
  // ... Export handlers ...
  return (
    <div>
      {/* Summary Cards */}
      {/* Pie Charts for Core, Tube, and ODP Utilization */}
      {/* Export Buttons */}
    </div>
  );
}
```

**Explanation:**
- Utilization data is visualized using `PieChart` components, with custom tooltips and legends for clarity.
- The tab provides a quick view of network efficiency and resource allocation.

### 4.2.2.3 Status Tab

The **Status** tab provides a breakdown of the status (active, archived, etc.) for each major entity in the FTTH network.

**Key Features:**
- Summary cards for total and active counts of locations, ODCs, ODPs, cables, and clients.
- Pie charts and bar charts showing the status distribution for each entity.
- Export buttons for CSV and PDF.

**Example: Status Tab Implementation**
```typescript
// client/src/pages/fo-reports/Status.tsx
export default function Status() {
  const [summary, setSummary] = useState({ ... });
  const [lokasiStatus, setLokasiStatus] = useState<any[]>([]);
  const [odcStatus, setOdcStatus] = useState<any[]>([]);
  const [odpStatus, setOdpStatus] = useState<any[]>([]);
  // ...
  useEffect(() => {
    request('GET', endpoint('/api/v1/ftth-statistics'))
      .then((response) => {
        setSummary(response.data.data.status);
        setLokasiStatus(response.data.data.charts.lokasiStatus);
        setOdcStatus(response.data.data.charts.odcStatus);
        setOdpStatus(response.data.data.charts.odpStatusPie);
        // ...
      });
  }, []);
  // ... Export handlers ...
  return (
    <div>
      {/* Summary Cards */}
      {/* Pie/Bar Charts for Status Distribution */}
      {/* Export Buttons */}
    </div>
  );
}
```

**Explanation:**
- The tab visualizes the health and operational state of the network, helping administrators quickly identify inactive or archived components.
- Charts are color-coded and include tooltips for better data interpretation.

### 4.2.2.4 Details Tab

The **Details** tab provides a hierarchical, drill-down view of the entire FTTH network, from locations down to individual clients.

**Key Features:**
- Nested cards/components for each level: Location → ODC → Kabel → Tube → Core → ODP → Client.
- Expand/collapse functionality for each entity to explore relationships.
- Export functionality for detailed data in CSV and PDF formats.

**Example: Details Tab Implementation**
```typescript
// client/src/pages/fo-reports/Details.tsx
export default function Details() {
  const [data, setData] = useState<any[]>([]);
  useEffect(() => {
    request('GET', endpoint('/api/v1/ftth-statistics'))
      .then((response) => {
        setData(response.data.data.detailed);
      });
  }, []);
  // ... Export handlers ...
  return (
    <div>
      {/* Hierarchical cards for each entity */}
      {/* Export Buttons */}
    </div>
  );
}
```

**Explanation:**
- The tab uses recursive/nested components to display the full network structure, allowing users to expand each level for more detail.
- The export feature flattens the hierarchy for CSV and renders the visible structure for PDF.

### 4.2.3 Export and User Experience Features

All tabs include export buttons for CSV and PDF, implemented using browser APIs and libraries (`jsPDF`, `html2canvas`, `papaparse`). Loading and error states are handled gracefully, and the dashboard is fully responsive for desktop and mobile use.

**Example: Export Handler**
```typescript
const handleExportCSV = () => {
  // Prepare and download CSV data
};
const handleExportPDF = async () => {
  // Render visible dashboard to PDF
};
```

### 4.2.4 Summary

The FTTH Reports module provides a powerful, user-friendly interface for analyzing and managing fiber optics infrastructure. By centralizing data aggregation in the backend and leveraging modern React components for visualization and export, the system delivers actionable insights and supports operational decision-making for network administrators.
