BAB IV  IMPLEMENTASI
4.1	Implementasi Pendataan CRUD Informasi Topologi dan Inventaris Fiber Optics
Implementasi sistem Informasi Topologi dan Inventaris Serat Optik dikembangkan menggunakan arsitektur aplikasi web modern dengan framework PHP Laravel untuk backend API dan React TypeScript untuk frontend client application. Sistem ini menyediakan operasi CRUD (Create, Read, Update, Delete) yang komprehensif untuk mengelola komponen infrastruktur serat optik termasuk lokasi, ODC (Optical Distribution Cabinet), kabel, tabung, core, ODP (Optical Distribution Point), dan klien FTTH.

4.1.1	Implementasi Backend Fiber Optic
Backend sistem ini dibangun menggunakan framework Laravel versi 10 dengan pendekatan arsitektur RESTful API. Sistem ini terdiri dari tujuh entitas utama yang membentuk struktur hierarkis untuk merepresentasikan topologi jaringan serat optik.

4.1.1.1	Desain Skema Database
Skema basis data dirancang dengan hubungan (relationships) dan batasan (constraints) yang sesuai untuk menjaga integritas data. Setiap tabel menerapkan mekanisme soft deletes untuk melindungi data dari penghapusan permanen dan dilengkapi dengan pengelolaan status untuk membedakan antara kondisi aktif dan arsip.

a.	FoLokasi (Lokasi)
Tabel 4. 1 Skema Database - FoLokasi
Schema::create('fo_lokasis', function (Blueprint $table) {
    $table->id();
    $table->string('nama_lokasi');
    $table->string('deskripsi')->nullable();
    $table->decimal('latitude', 10, 7);
    $table->decimal('longitude', 10, 7);
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
•	Tabel utama yang berisi lokasi geografis dengan koordinat lintang/bujur
•	Berisi: id, nama_lokasi, deskripsi, lintang, bujur, status, dihapus_pada, stempel waktu
•	Kolom status berisi ‘aktif’ dan 'diarsipkan'
•	Mengimplementasikan penghapusan lunak untuk pelestarian data
b.	FoOdc (Optical Distribution Cabinets)
Tabel 4. 2 Skema Database - FoOdc
Schema::create('fo_odcs', function (Blueprint $table) {
    $table->id();
    $table->foreignId('lokasi_id')->constrained('fo_lokasis')
->cascadeOnDelete()->cascadeOnUpdate();
    $table->string('nama_odc');
    $table->enum('tipe_splitter', ['1:2', '1:4', '1:8', '1:16', '1:32', '1:64', '1:128']);
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
•	Mewakili peralatan ODC di setiap lokasi
•	Relasi Foreign Key dengan tabel fo_lokasis
•	Kolom: id, lokasi_id, nama_odc, tipe_splitter, status, deleted_at, timestamps
•	Tipe splitter: 1:2, 1:4, 1:8, 1:16, 1:32, 1:64, 1:128
c.	FoKabelOdc (Kabel ODC)
Tabel 4. 3 Skema Database - FoKabelOdc
Schema::create('fo_kabel_odcs', function (Blueprint $table) {
    $table->id();
    $table->foreignId('odc_id')->constrained('fo_odcs')->cascadeOnDelete()->cascadeOnUpdate();
    $table->string('nama_kabel');
    $table->enum('tipe_kabel', ['singlecore', 'multicore']);
    $table->decimal('panjang_kabel', 8, 2);
    $table->integer('jumlah_tube');
    $table->integer('jumlah_core_in_tube');
    $table->integer('jumlah_total_core'); // Dihitung otomatis
    $table->enum('status', ['active', 'archived'])->default('active');
    $table->softDeletes();
    $table->timestamps();
});
protected static function boot()
{
    parent::boot();
    static::saving(function (FoKabelOdc $model) {
    $model->jumlah_total_core = $model->jumlah_tube * $model
    ->jumlah_core_in_tube;
    });
}
•	Mengelola informasi kabel yang terhubung ke ODCs
•	Relasi Foreign Key dengan tabel fo_odcs
•	Kolom: id, odc_id, nama_kabel, tipe_kabel, panjang_kabel, jumlah_tube, jumlah_core_in_tube, jumlah_total_core, status, deleted_at, timestamps
•	Jenis kabel: singlecore, multicore
•	Perhitungan otomatis jumlah total inti (jumlah_total_core = jumlah_tube × jumlah_core_in_tube)
d.	FoKabelTubeOdc (Tube Kabel ODC)
Tabel 4. 4 Skema Database - FoKabelTubeOdc
Schema::create('fo_kabel_tube_odcs', function (Blueprint $table) {
   $table->id();
   $table->foreignId('kabel_odc_id')->constrained('fo_kabel_odcs')
         ->cascadeOnDelete()->cascadeOnUpdate();
   $table->enum('warna_tube', ['biru', 'jingga', 'hijau', 'coklat',
                'abu_abu', 'putih', 'hitam', 'kuning', 'ungu',
                'merah_muda', 'aqua']);
   $table->enum('status', ['active', 'archived'])->default('active');
   $table->softDeletes();
   $table->timestamps();
});
•	Merepresentasikan tube individu dalam kabel
•	Relasi Foreign Key dengan tabel fo_kabel_odcs
•	Kolom: id, kabel_odc_id, warna_tube, status, deleted_at, timestamps
•	Warna tabung: biru, jingga, hijau, coklat, abu-abu, putih, merah, hitam, kuning, ungu, merah muda, aqua
e.	FoKabelCoreOdc (Core Kabel ODC)
Tabel 4. 5 Skema Database - FoKabelCoreOdc
Schema::create(‘fo_kabel_core_odcs', function (Blueprint $table) {
   $table->id();
   $table->foreignId('kabel_tube_odc_id')
         ->constrained('fo_kabel_tube_odcs')
         ->cascadeOnDelete->cascadeOnUpdate();
   $table->enum('warna_tube', ['biru', 'jingga', 'hijau', 'coklat',
                'abu_abu', 'putih', 'hitam', 'kuning', 'ungu',
                'merah_muda', 'aqua']);
   $table->enum('status', ['active', 'archived'])->default('active');
   $table->softDeletes();
   $table->timestamps();
});
•	Merepresentasikan core individu di dalam tube
•	Kunci asing ke tabel fo_kabel_tube_odcs
•	Kolom: id, kabel_tube_odc_id, warna_core, status, deleted_at, timestamps
•	Warna serat: sama dengan warna tabung
f.	FoOdp (Optical Distribution Points)
Tabel 4. 6 Skema Database - FoOdp
Schema::create(‘fo_odps’, function (Blueprint $table) {
   $table->id();
   $table->foreignId('kabel_core_odc_id')
         ->constrained('fo_kabel_core_odcs')
         ->cascadeOnDelete->cascadeOnUpdate()->nullable()->change();
   $table->foreignId('lokasi_id')->constrained('fo_lokasis')
          ->cascadeOnDelete()->cascadeOnUpdate();
   $table->string('nama_odp');
   $table->enum('status', ['active', 'archived'])->default('active');
   $table->softDeletes();
   $table->timestamps();
});
•	Titik ODP yang terhubung ke cores
•	Relasi Foreign Key dengan tabel fo_kabel_core_odcs
•	Kolom: id, lokasi_id, kabel_core_odc_id, nama_odp, status, deleted_at, timestamps
•	Hubungan satu-ke-satu dengan inti (Unique Constrain)
g.	FoClientFtth (Klien FTTH)
Tabel 4. 7 Skema Database - FoClientFtth
Schema::create('fo_client_ftths', function (Blueprint $table) {
   $table->id();
   $table->foreignId('lokasi_id')
         ->constrained('fo_lokasis')
         ->cascadeOnDelete->cascadeOnUpdate();
   $table->foreignId('odp_id')
         ->constrained('fo_odps')
         ->cascadeOnDelete->cascadeOnUpdate();
   $table->unsignedInteger('client_id')->nullable();
   $table->foreign('client_id')->references('id')->on('clients')
         ->onDelete('cascade')->onUpdate('cascade');
   $table->unsignedInteger('company_id');
   $table->foreign('company_id')->references('id')->on('companies')
         ->onDelete('cascade')->onUpdate('cascade');
   $table->string('nama_client')->nullable();
   $table->string('alamat')->nullable();
   $table->enum('status', ['active', 'archived'])->default('active');
   $table->softDeletes();
   $table->timestamps();
});
•	Client FTTH yang terhubung ke jaringan fiber optik
•	Relasi Foreign Key dengan tabel fo_lokasis, fo_odps, clients, dan companies
•	Kolom: id, lokasi_id, odp_id, client_id, company_id, nama_klien, alamat, status, deleted_at, timestamps
f. FoJointBox
{add here !!!}

4.1.1.2	Relasi Model dan Eloquent ORM
Model Eloquent pada Laravel diimplementasikan dengan relasi yang tepat untuk memastikan integritas data dan mendukung query yang efisien berikut salah satu contoh pada model FoLokasi :

Tabel 4. 8 Relasi Model dan Eloquent ORM
// app/Models/FoLokasi.php
class FoLokasi extends Model
{
    use SoftDeletes;
    protected $fillable = [
        'nama_lokasi', 'deskripsi', 'latitude', 'longitude', 'status'
    ];
    protected $casts = [
        'latitude' => 'float',
        'longitude' => 'float',
        'status' => 'string',
        'deleted_at' => 'datetime',
    ];
    public function odcs()
    {
        return $this->hasMany(FoOdc::class, 'lokasi_id');
    }
    public function odps()
    {
        return $this->hasMany(FoOdp::class, 'lokasi_id');
    }
    public function clientFtths()
    {
        return $this->hasMany(FoClientFtth::class, 'lokasi_id');
    }
}
Berikut detail relasi untuk setiap model :
•	FoLokasi memiliki banyak FoOdc, FoOdp, dan FoClientFtth
•	FoOdc merupakan bagian dari FoLokasi dan memiliki banyak FoKabelOdc
•	FoKabelOdc merupakan bagian dari FoOdc dan memiliki banyak FoKabelTubeOdc
•	FoKabelTubeOdc merupakan bagian dari FoKabelOdc dan memiliki banyak FoKabelCoreOdc
•	FoKabelCoreOdc merupakan bagian dari FoKabelTubeOdc dan memiliki satu FoOdp
•	FoOdp merupakan bagian dari FoLokasi dan FoKabelCoreOdc, memiliki satu FoClientFtth
•	FoClientFtth merupakan bagian dari FoLokasi, FoOdp, Client, dan Company

4.1.1.3	Implementasi Controller API
Enam controller dengan pendekatan RESTful diimplementasikan untuk mendukung operasi CRUD secara menyeluruh. Setiap controller mengikuti praktik terbaik Laravel, termasuk validasi data, penanganan kesalahan, dan pemformatan respons yang konsisten.
a.	FoLokasiController - Metode Index dengan Filter
Tabel 4. 9 Controller - Index
public function index(Request $request)
{
    // Parse parameter status untuk filter
    $statusParam = $request->query('status', 'active');
    $requested = collect(explode(',', $statusParam))
        ->map(fn($s) => trim(strtolower($s)))
        ->filter()
        ->unique()
        ->values()
        ->all();

    $validStatuses = ['active', 'archived', 'deleted'];
    $statuses = array_values(array_intersect($requested, $validStatuses));
    if (empty($statuses)) {
        $statuses = ['active'];
    }

    // Query dasar dengan dukungan trashed
    $query = FoLokasi::withTrashed();

    // Filter berdasarkan status dengan logika kompleks
    $query->where(function ($q) use ($statuses) {
        if (in_array('deleted', $statuses, true)) {
            $q->orWhereNotNull('deleted_at');
        }

        $nonDeleted = array_values(array_intersect($statuses, ['active', 'archived']));
        if (!empty($nonDeleted)) {
            $q->orWhere(function ($sub) use ($nonDeleted) {
                $sub->whereNull('deleted_at')
                    ->whereIn('status', $nonDeleted);
            });
        }
    });

    // Filter teks
    if ($request->filled('filter')) {
        $term = $request->query('filter');
        $query->where(function ($q) use ($term) {
            $q->where('nama_lokasi', 'LIKE', "%{$term}%")
                ->orWhere('deskripsi', 'LIKE', "%{$term}%");
        });
    }

    // Pengurutan dengan validasi
    if ($request->filled('sort')) {
        [$column, $dir] = array_pad(explode('|', Chater 4 implementation.txtrequest->query('sort')), 2, null);
        $dir = (strtolower($dir) === 'dsc') ? 'desc' : 'asc';

        $allowedSorts = ['id', 'nama_lokasi', 'created_at', 'updated_at', 'status'];
        if (in_array($column, $allowedSorts, true)) {
            $query->orderBy($column, $dir);
        }
    } else {
        $query->orderBy('id', 'desc');
    }

    // Paginasi dengan pemuatan relasi
    $perPage = (int) $request->query('per_page', 15);
    if ($perPage <= 0) $perPage = 15;

    $paginator = $query
        ->with(['odcs', 'odps', 'clientFtths'])
        ->paginate($perPage)
        ->appends($request->only(['filter', 'sort', 'per_page', 'status']));

    // Transformasi data untuk respons yang konsisten
    $data = array_map(function ($l) {
        return [
            'id' => $l->id,
            'nama_lokasi' => $l->nama_lokasi,
            'deskripsi' => $l->deskripsi,
            'latitude' => $l->latitude,
            'longitude' => $l->longitude,
            'status' => $l->status,
            'odcs' => $l->odcs->map(fn($o) => [
                'id' => $o->id,
                'nama_odc' => $o->nama_odc,
            ])->toArray(),
            'odps' => $l->odps->map(fn($o) => [
                'id' => $o->id,
                'nama_odp' => $o->nama_odp,
            ])->toArray(),
            'clients' => $l->clientFtths->map(fn($c) => [
                'id' => $c->id,
                'nama_client' => $c->nama_client,
            ])->toArray(),
            'created_at' => $l->created_at->toDateTimeString(),
            'updated_at' => $l->updated_at->toDateTimeString(),
            'deleted_at' => $l->deleted_at?->toDateTimeString(),
        ];
    }, $paginator->items());

    return response()->json([
        'status' => 'success',
        'data' => $data,
        'meta' => [
            'current_page' => $paginator->currentPage(),
            'per_page' => $paginator->perPage(),
            'total' => $paginator->total(),
            'last_page' => $paginator->lastPage(),
            'from' => $paginator->firstItem(),
            'to' => $paginator->lastItem(),
        ],
    ], 200);
}
b.	Metode Store dengan Validasi
Tabel 4. 10 Controller - Store
public function store(Request $request)
{
    $data = $request->validate([
        'nama_lokasi' => 'required|string|max:255',
        'deskripsi' => 'nullable|string|max:255',
        'latitude' => 'required|numeric',
        'longitude' => 'required|numeric',
        'status' => 'sometimes|in:active,archived',
    ]);

    // Default ke active jika tidak disediakan
    if (!isset($data['status'])) {
        $data['status'] = 'active';
    }

    $lokasi = FoLokasi::create($data);

    return response()->json([
        'status' => 'success',
        'data' => [
            'id' => $lokasi->id,
            'nama_lokasi' => $lokasi->nama_lokasi,
            'deskripsi' => $lokasi->deskripsi,
            'latitude' => $lokasi->latitude,
            'longitude' => $lokasi->longitude,
            'status' => $lokasi->status,
            'created_at' => $lokasi->created_at->toDateTimeString(),
            'updated_at' => $lokasi->updated_at->toDateTimeString(),
        ],
        'message' => 'Lokasi berhasil dibuat.',
    ], 201);
}
c.	Implementasi Bulk Operations
Tabel 4. 11 Controller - Bulk Operation
public function bulk(Request $request)
{
    $data = $request->validate([
        'action' => 'required|in:archive,delete,restore',
        'ids' => 'required|array|min:1',
        'ids.*' => 'integer|distinct',
    ]);

    $ids = $data['ids'];
    $action = $data['action'];

    switch ($action) {
        case 'archive':
            $this->model::withTrashed()
                ->whereIn('id', $ids)
                ->update(['status' => 'archived']);
            $message = 'Item diarsipkan.';
            break;

        case 'delete':
            $this->model::whereIn('id', $ids)->delete();
            $message = 'Item dihapus secara soft.';
            break;

        case 'restore':
            $this->model::onlyTrashed()
                ->whereIn('id', $ids)
                ->restore();
            $this->model::whereIn('id', $ids)
                ->update(['status' => 'active']);
            $message = 'Item dipulihkan ke aktif.';
            break;

        default:
            return response()->json([
                'status' => 'error',
                'message' => 'Aksi tidak valid.',
            ], 422);
    }

    return response()->json([
        'status' => 'success',
        'message' => $message,
    ], 200);
}

4.1.1.4	Konfigurasi Rute API
Rute API dikonfigurasi dengan middleware yang sesuai dan mengikuti pola RESTful:
Tabel 4. 12 API Routes
Route::group(['middleware' => ['throttle:api', 'api_db', 'token_auth', 'locale'], 'prefix' => 'api/v1', 'as' => 'api.'], function () {

    // Rute FoLokasi
    Route::get('/fo-lokasis', [FoLokasiController::class, 'index']);
    Route::post('/fo-lokasis', [FoLokasiController::class, 'store']);
    Route::get('/fo-lokasis/{id}', [FoLokasiController::class, 'show']);
    Route::put('/fo-lokasis/{id}', [FoLokasiController::class, 'update']);
    Route::patch('/fo-lokasis/{id}', [FoLokasiController::class, 'update']);
    Route::delete('/fo-lokasis/{id}', [FoLokasiController::class, 'destroy']);
    Route::patch('/fo-lokasis/{id}/archive', [FoLokasiController::class, 'archive']);
    Route::patch('/fo-lokasis/{id}/unarchive', [FoLokasiController::class, 'unarchive']);
    Route::patch('/fo-lokasis/{id}/restore', [FoLokasiController::class, 'restore']);
    Route::post('/fo-lokasis/bulk', [FoLokasiController::class, 'bulk']);

    // Pola serupa untuk semua entitas lainnya...
    Route::get('/fo-odcs', [FoOdcController::class, 'index']);
    Route::post('/fo-odcs', [FoOdcController::class, 'store']);
    // ... rute tambahan untuk setiap entitas
});

4.1.2	Implementasi Frontend Fiber Optics

Pada sisi frontend, aplikasi FTTH dikembangkan menggunakan React dengan TypeScript untuk memastikan pengalaman pengguna yang responsif, modern, dan mudah dikembangkan. Frontend berperan sebagai antarmuka utama bagi pengguna untuk mengelola data topologi dan inventaris jaringan serat optik, serta mengakses laporan FTTH secara interaktif. Setiap fitur frontend dirancang agar mudah digunakan, mendukung validasi data secara real-time, dan terintegrasi penuh dengan backend API berbasis Laravel.

4.1.2.1	Arsitektur Aplikasi dan Konfigurasi Routes

Struktur aplikasi frontend dibangun secara modular, di mana setiap entitas utama (Lokasi, ODC, Kabel, Tube, Core, ODP, Client FTTH, Joint Box) memiliki folder dan komponen tersendiri. Routing diatur menggunakan React Router, sehingga setiap halaman (index, create, edit, show) dapat diakses melalui URL yang konsisten dan mudah dipahami. Konfigurasi routes juga memudahkan pengembangan fitur baru dan pemeliharaan aplikasi dalam jangka panjang.

4.1.2.2	Implementasi Components dengan Typescript

Setiap entitas memiliki komponen utama seperti tabel data (data table), form input, dan detail view. Komponen-komponen ini ditulis dengan TypeScript untuk memastikan type safety dan mengurangi potensi bug. Data yang diambil dari backend API ditampilkan dalam tabel interaktif yang mendukung pencarian, filter, dan sorting. Komponen form dirancang reusable, sehingga dapat digunakan baik untuk create maupun edit data.

4.1.2.3	Implementasi Form dengan Validasi

Form input pada aplikasi ini dilengkapi dengan validasi real-time, baik di sisi frontend maupun backend. Validasi frontend memastikan data yang dimasukkan pengguna sudah benar sebelum dikirim ke server, seperti validasi koordinat lokasi, format nama, dan relasi antar entitas. Jika terjadi error, pesan kesalahan akan langsung ditampilkan sehingga pengguna dapat segera memperbaiki inputnya.

4.1.2.4	Implementasi Halaman Indeks

Setiap entitas memiliki halaman indeks yang menampilkan daftar data dalam bentuk tabel. Tabel ini mendukung fitur pencarian, filter status (active, archived, deleted), sorting kolom, dan paginasi. Pengguna dapat dengan mudah melihat data yang sudah ada, melakukan aksi bulk (arsip, hapus, restore), serta mengakses detail atau mengedit data tertentu. Halaman indeks juga menjadi pintu masuk utama untuk navigasi ke fitur create atau detail.

4.1.2.5	Implementasi Form dengan Manajemen Relasi

Form pada ntitas yang memiliki relasi (misal ODC ke Lokasi, Kabel ke ODC, ODP ke Core, Client ke ODP) dilengkapi dengan dropdown atau autocomplete yang mengambil data dari API terkait. Dengan demikian, pengguna dapat memilih relasi yang valid dan data yang dimasukkan tetap konsisten. Jika relasi belum ada, pengguna juga dapat membuat entitas baru langsung dari form (misal tambah lokasi baru saat membuat ODC).

4.1.2.6	Implementasi Form Custom pada KabelOdc

Pada form entitas Kabel ODC, pengguna dapat memilih warna tube secara interaktif menggunakan komponen TubeColorPicker. Komponen ini menampilkan daftar warna standar tube fiber optik, dan pengguna dapat memilih beberapa warna tanpa duplikasi. Berikut adalah cuplikan kode utama komponen TubeColorPicker (lihat `client/src/pages/fo-kabel-odcs/common/components/TubeColorPicker.tsx`):

```typescript
const TUBE_COLORS = [
  { value: 'biru', label: 'Biru', color: '#2196f3' },
  { value: 'jingga', label: 'Jingga', color: '#ff9800' },
  // ... warna lain ...
];

export function TubeColorPicker({ value, onChange, disabledColors = [] }) {
  // Helper: is color selected
  const isSelected = (color: string) => value.includes(color);
  // Add color
  const addColor = (color: string) => {
    if (!isSelected(color)) {
      onChange([...value, color]);
    }
  };
  // Remove color
  const removeColor = (color: string) => {
    onChange(value.filter((c) => c !== color));
  };
  return (
    <div className="flex flex-wrap gap-2">
      {TUBE_COLORS.map((c) => {
        const selected = isSelected(c.value);
        // ... styling ...
        return (
          <button
            key={c.value}
            type="button"
            // ... styling ...
            onClick={() => (selected ? removeColor(c.value) : addColor(c.value))}
          >
            <span>{c.label}</span>
            {selected && <span className="ml-2 text-lg font-bold">×</span>}
          </button>
        );
      })}
    </div>
  );
}
```

Komponen ini memastikan pemilihan warna tube sesuai standar dan mencegah duplikasi, serta memberikan feedback visual yang jelas kepada pengguna.

4.1.2.7	Implementasi Geocoding pada FoLokasi

Fitur geocoding pada FoLokasi memungkinkan pengguna untuk melakukan "Force Geocode" atau "Re-geocode" pada data lokasi. Proses ini memanggil endpoint backend untuk mendapatkan informasi geografis berdasarkan koordinat yang diinput. Berikut adalah cuplikan kode handler geocoding pada frontend (lihat `client/src/pages/fo-lokasis/common/hooks/useFoLokasiActions.tsx`):

```typescript
const handleForceGeocode = async (id: string) => {
    try {
        const response = await request('POST', endpoint(`/api/v1/fo-lokasis/${id}/geocode`));
        if (response.data.status === 'success') {
            toast.success('Location geocoded successfully!');
            queryClient.invalidateQueries(['/api/v1/fo-lokasis']);
            // ... refresh data table ...
        } else {
            toast.error('Failed to geocode location');
        }
    } catch (error) {
        toast.error('Failed to geocode location. Please try again.');
    }
};
```

Handler ini di-trigger dari menu aksi pada tabel lokasi, dan akan memperbarui data lokasi dengan hasil geocoding terbaru secara otomatis setelah proses berhasil.

4.2	Implementasi FTTH Reports

Sistem laporan FTTH (Fiber to the Home) pada aplikasi ini dirancang untuk memberikan analisis menyeluruh dan visualisasi data infrastruktur serat optik secara real-time. Modul ini terdiri dari backend API yang mengagregasi data dari seluruh entitas fiber optik, serta frontend dashboard interaktif yang menampilkan data dalam bentuk tabulasi, grafik, dan hierarki.

4.2.1	Backend API Implementation

Backend untuk laporan FTTH diimplementasikan melalui satu endpoint utama, yaitu `/api/v1/ftth-statistics` yang di-handle oleh `FtthStatisticController` (lihat file `app/Http/Controllers/FtthStatisticController.php` baris 1-321). Endpoint ini melakukan agregasi data dari seluruh tabel utama (lokasi, ODC, ODP, kabel, tube, core, client FTTH, joint box) dan menghasilkan statistik summary, breakdown status, utilisasi, serta data detail untuk drill-down.

Contoh logika agregasi pada controller:
- Menghitung total entitas (lokasi, ODC, ODP, kabel, tube, core, client, joint box)
- Menghitung utilisasi core, tube, dan ODP (berapa yang sudah terpakai/terhubung)
- Membuat breakdown status (active, archived, deleted) untuk setiap entitas
- Menyiapkan data untuk grafik (bar chart, pie chart) seperti distribusi ODP per ODC, client per ODP, dsb
- Menyusun data hierarkis untuk tab Details

Semua data ini dikemas dalam satu response JSON yang siap dikonsumsi frontend.

4.2.2	Overview Tab

Tab Overview pada frontend (lihat file `client/src/pages/fo-reports/Overview.tsx` baris 1-357) menampilkan ringkasan utama infrastruktur FTTH. Pengguna dapat melihat total lokasi, ODC, ODP, kabel, panjang kabel, tube, core, client FTTH, dan joint box. Selain itu, terdapat grafik batang (bar chart) yang memperlihatkan distribusi ODP pada setiap ODC dan distribusi client pada setiap ODP.

Fitur utama:
- Kartu summary (total entitas dan utilisasi)
- Grafik batang ODP per ODC dan client per ODP
- Tombol ekspor data ke CSV dan PDF

Tab ini sangat berguna untuk memberikan gambaran cepat (high-level) kondisi jaringan FTTH.

4.2.3	Utilization Tab

Tab Utilization (lihat file `client/src/pages/fo-reports/Utilization.tsx` baris 1-325) berfokus pada analisis pemanfaatan sumber daya jaringan. Di sini, pengguna dapat melihat berapa banyak core, tube, dan ODP yang sudah digunakan dibandingkan total yang tersedia. Visualisasi dilakukan dengan pie chart yang menampilkan proporsi assigned/unassigned core, used/unused tube, dan ODP yang sudah memiliki client.

Fitur utama:
- Kartu summary utilisasi core, tube, dan ODP
- Pie chart utilisasi (dengan persentase)
- Ekspor data ke CSV dan PDF

Tab ini membantu admin untuk mengidentifikasi efisiensi dan potensi bottleneck pada jaringan.

4.2.4	Status Tab

Tab Status (lihat file `client/src/pages/fo-reports/Status.tsx` baris 1-560) memberikan breakdown status (active, archived, deleted) untuk setiap entitas utama (lokasi, ODC, ODP, kabel, client, joint box). Data divisualisasikan dalam bentuk pie chart dan bar chart, sehingga memudahkan identifikasi entitas yang tidak aktif atau bermasalah.

Fitur utama:
- Kartu summary status total dan active
- Pie chart status per entitas
- Bar chart breakdown status keseluruhan
- Ekspor data ke CSV dan PDF

Tab ini sangat penting untuk monitoring kesehatan dan status operasional jaringan.

4.2.5	Details Tab

Tab Details (lihat file `client/src/pages/fo-reports/Details.tsx` baris 1-1090) menampilkan data secara hierarkis dan mendalam, mulai dari lokasi → ODC → kabel → tube → core → ODP → client. Setiap entitas dapat diexpand/collapse untuk melihat detail dan relasi antar entitas. Terdapat juga fitur filter geografis (negara, provinsi, kota) dan grouping.

Fitur utama:
- Tampilan hierarkis (drill-down) seluruh jaringan
- Filter dan grouping berdasarkan lokasi geografis
- Ekspor data detail ke CSV dan PDF

Tab ini sangat berguna untuk analisis mendalam, audit, dan troubleshooting jaringan.

4.2.6	Fungsi Ekspor

Seluruh tab laporan FTTH dilengkapi dengan fitur ekspor data ke format CSV dan PDF. Implementasi ekspor CSV menggunakan library `papaparse`, sedangkan ekspor PDF menggunakan kombinasi `jsPDF` dan `html2canvas` untuk menangkap tampilan dashboard secara visual.

Fitur ekspor ini memudahkan admin untuk mendokumentasikan, membagikan, atau menganalisis data di luar aplikasi.

Dengan arsitektur ini, sistem laporan FTTH mampu memberikan insight yang komprehensif, real-time, dan mudah diakses, mendukung pengambilan keputusan dan monitoring operasional jaringan fiber optik secara efisien.
